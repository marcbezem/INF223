\documentclass[handout]{beamer}
%\documentclass[slides]{beamer}
% Vary the color applet  (try out your own if you like)
%\colorlet{structure}{red!20!black}
%\beamertemplateshadingbackground{yellow!20}{white}
%\usepackage{beamerthemeshadow}
%\usepackage[utf8x]{inputenc} CONFLICT!
\usepackage{tikz}
%\usepackage[english,norsk,nynorsk]{babel}
\usepackage{tikz-cd}
\usetikzlibrary{trees}

\usepackage[all]{xy}
\usepackage{multicol}

%\setbeamertemplate{navigation symbols}{}++++++
%\setbeamertemplate{footline}[frame number]
\usetheme{Montpellier}


\input macros

\newcommand{\To}{\Rightarrow}
\newcommand{\Trt}{\stackrel{*}{\Rightarrow}}
\newcommand{\ToG}{\Rightarrow_G}
\newcommand{\redS}{{\color{red} S}}

\newcommand{\bfsf}[1]{{\boldsymbol{#1}}}
\newcommand{\Set}{\bfsf{Set}}
\newcommand{\Gra}{\bfsf{Graph}}
\newcommand{\CC}{\bfsf{C}}
\newcommand{\DD}{\bfsf{D}}
\newcommand{\EE}{\bfsf{E}}
\newcommand{\PP}{\bfsf{P}}
\newcommand{\HH}{\bfsf{H}}
\newcommand{\Nat}{\bfsf{Nat}}
\newcommand{\Incl}{\bfsf{Incl}}
\newcommand{\Rel}{\bfsf{Rel}}
\newcommand{\Mult}{\bfsf{Mult}}
\newcommand{\Mon}{\bfsf{Mon}}
\newcommand{\Cat}{\bfsf{Cat}}
\newcommand{\CAT}{\bfsf{CAT}}

\newcommand{\Kp}[1]{{\langle #1 \rangle}}
\newcommand{\Kc}{;\!;}
\newcommand{\bind}{{>}\!\!{>}\!{=}}
\newcommand{\ttt}[1]{\text{\tt #1}}

\title[INF223 presentations]{}

\begin{document}

\section{Monads}
\subsection{Introduction}
 
\frame
  {   
    \frametitle{Monads}\label{Mon5:Intro}

 \begin{itemize}[<+->]
\item Monad is a notion in CT that turned out to be useful in programming
\item Monad was defined in CT in the 1950's and 1960's
\item A breakthrough paper for application in CS was 
\href{https://person.dibris.unige.it/moggi-eugenio/ftp/ic91.pdf}{\color{blue}E. Moggi, Notions of computation and monads, I\&C, 93(1), 1991}
\item We start by giving an example, and then carefully abstract from that
to arrive at a categorical notion
\item Useful links are:
 \begin{itemize}
    \item \myurl{https://ncatlab.org/nlab/show/monad+\%28in+computer+science\%29}
    \item \myurl{https://ncatlab.org/nlab/show/extension+system}
 \end{itemize}
 \end{itemize}

 }

\frame
  {   
    \frametitle{Example of a monad (one)}\label{Mon5:ExaSetMone}

 \begin{itemize}[<+->]
\item We work in the category $\Set$ and fix a monoid $(M,1,*)$
\item The example models functions that have side-effects, e.g., writing a
string (strings with the empty string and concatenation form a monoid)
\item Operation $T$ on sets is defined by $T(X)= X\times M$
\item Map $f : X\to Y$ with side-effect $p : X\to M$ is modelled as $\Kp{f,p} : X\to T(Y)$
%$p$ gives the monoid value as a side-effect of $f$
\item For every set $X$ we define $unit_X: X\to T(X)$ mapping $x\in X$ to $(x,1)$,
so $unit_X = \Kp{id_X,x\mapsto 1}$
\item For the moment $unit_X$ is just an example, but it will turn out to
be some kind of neutral element
 \end{itemize}
 }

\frame
  {   
    \frametitle{Example of a monad (two)}\label{Mon5:ExaSetMtwo}

 \begin{itemize}[<+->]
\item For $\Kp{f,p}: X\to T(Y)$ and $\Kp{g,q}: Y\to T(Z)$ we define a special
composition $\Kp{f,p}\Kc \Kp{g,q} = \Kp{f;g,r} : X\to T(Z)$ with $$r(x)=p(x)*q(f(x))$$
Thus the monoid-valued-side-effect is cumulative,
we multiply the old value $p(x)$ by the new value $q(f(x))$,
or, we append the string $q(f(x))$ to the string $p(x)$.
\item Indeed we get an identity law: for $\Kp{f,p}: X\to T(Y)$ we have
$$unit_X\Kc \Kp{f,p}  = \Kp{f,p} = \Kp{f,p}\Kc unit_Y$$
\item Also, the special composition $\Kc$ is associative  (exercise)
\item Note that the left and right unit are (subtly) different.
We don't have a new \emph{monoid}, but we do have a \emph{monad}.
 \end{itemize}

 }

\frame
  {   
    \frametitle{Categorical abstraction (one)}\label{Mon5:CatAbstrOne}

 \begin{itemize}[<+->]
\item For $\Kp{f,p} : X\to T(Y)$ we define $\Kp{f,p}^T : T(X)\to T(Y)$ by
$$\Kp{f,p}^T(x,v) = (f(x),v*p(x))$$
\item Exercise: show $\Kp{f,p}\Kc\Kp{g,q} = \Kp{f,p};\Kp{g,q}^T$
\item Preparing for abstraction from the example,
we extend $T$ to a functor $\Set\to\Set$ 
by setting, for any $f:X\to Y$,  $$T(f) = (f; unit_Y)^T : T(X)\to T(Y)$$
\item In effect: $T(f) = f\times id_M$ and, as required for a functor,
\begin{itemize}
\item for all $X$,
$T(id_X) = id_X \times id_M = id_{X\times M} = id_{T(X)}$
\item for all $f:X\to Y$ and $g:Y\to Z$, $T(f;g) = (f;g)\times id_M =
(f\times id_M);(g\times id_M) = T(f); T(g)$
\end{itemize}
 \end{itemize}

 }

\frame
  {   
    \frametitle{Categorical abstraction (two)}\label{Mon5:CatAbstrTwo}

 \begin{itemize}[<+->]
\item With $T$ a functor the family $unit_X: X\to T(X)$ appears to be
a natural transformation $id_\Set \To T$, with naturality square:
%\varepsilon:
\[
\begin{tikzcd}[ampersand replacement=\&]
X \arrow[swap]{d}{f} \& X  \arrow[swap]{d}{f}\arrow{r}{unit_X} \&\arrow{d}{T(f)} T(X)\\
Y \& Y  \arrow{r}{unit_Y} \& T(Y)
\end{tikzcd}
\]
$(f;unit_Y)(x)=(f(x),1) = T(f)(x,1) = (unit_X;T(f))(x)$
\item Next,  we want to get the special composition right
\item Maps $\Kp{f,p}: X\to T(Y)$ and $\Kp{g,q}: Y\to T(Z)$ cannot be composed
in $\Set$, but $T(\Kp{g,q}) : T(Y) \to T(T(Z))$ gives the composite
$$\Kp{f,p};T(\Kp{g,q}) : X \to T(T(Z))$$
\item Not there yet: type should be $X \to T(Z)$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Categorical abstraction (three)}\label{Mon5:CatAbstrThree}

 \begin{itemize}[<+->]
\item Note $T(\Kp{g,q})(y,w) =  (\Kp{g,q}(y),w) = ((g(y),q(y)),w)$, so
$(\Kp{f,p};T(\Kp{g,q}))(x) = (g(f(x)),q(f(x))),p(x)): T(T(Z))$
\item Recall: $(\Kp{f,p}\Kc \Kp{g,q})(x) = (g(f(x)),p(x)*q(f(x)) : T(Z)$
\item The missing step from $T(T(Z))$ to $T(Z)$ is taken by
$$\mu_Z: T(T(Z))\to T(Z): ((z,m_{new}),m_{old}) \mapsto (z,m_{old}*m_{new})$$
and $\mu$ is a natural transformation, the \emph{monad multiplication}:
\[
\begin{tikzcd}[ampersand replacement=\&]
X \arrow[swap]{d}{f} \& T(T(X))  \arrow[swap]{d}{T(T(f))}\arrow{r}{\mu_X} \&\arrow{d}{T(f)} T(X)\\
Y \& T(T(Y))  \arrow{r}{\mu_Y} \& T(Y)
\end{tikzcd}
\]
since $\mu_Y(T(T(f))((x,m'),m)) = \mu_Y((f(x),m'),m) = (f(x), m*m') 
= T(f)(x,m*m') = T(f)(\mu_X((x,m'),m))$
 \end{itemize}

 }

\frame
  {   
    \frametitle{A categorical definition of monad}\label{Mon5:CatDefMonad}

 \begin{itemize}[<+->]
\item A \emph{monad} consists of the following data:
 \begin{enumerate}
    \item a category $\CC$
    \item a functor $T:\CC\to\CC$
    \item a natural transformation $\eta: id_\CC \To T$ (the \emph{monad unit})
    \item a natural transformation $\mu: T;T \To T$ (the \emph{multiplication})
 \end{enumerate}
satisfying the following properties:
 \begin{enumerate}
    \item $\eta_{T(A)};\mu_A = id_{T(A)} = T(\eta_A);\mu_A$ (the \emph{monad identity} laws)
    \item $T(\mu_A);\mu_A = \mu_{T(A)};\mu_A$ (the \emph{monad associativity} law)
 \end{enumerate}
\item Exercise: verify that all equalities above are well-typed
\item We carefully review the example from the previous slides to 
make sure the it was indeed a monad. 
The terms \emph{monad unit, multiplication} etc.\ will get meaning. 
 \end{itemize}

 }

\frame
  {   
    \frametitle{Some informal explanations}\label{Mon5:InfoMonad}

 \begin{itemize}[<+->]
\item One view on a monad $(\CC,T,\eta,\mu)$ is that the objects $T(A)$ are $A$
with some structure added, described by $\eta,\mu$. The following explanation
makes only sense for some categories $\CC$, such as $\Set$ and $\HH$ 
(sets/types + functions).
\item $T(A)$ can be viewed as the set/type of $A$-values with {\color{red}extras (!)}
\item $\eta_A : A\to T(A)$ adds a neutral extra, say 1, to any $A$ value
\item $\eta_{T(A)} : T(A)\to T^2(A)$ adds this 1 to any $T(A)$-value $(a,e)$
\item $\mu_A: T^2(A)\to T(A)$ {\color{red}combines (!)} two extras into one
\item $\eta_{T(A)};\mu_A = id_{T(A)}$ means $\mu_A((a,e),1) = (a,e)$, cf.\ $e*1=e$
\item For $f:A\to B$ the `natural' $T(f)$ maps $(a,e)$ to $(f(a),e)$
\item Hence $T(\eta_A) : T(A)\to T^2(A)$ maps $(a,e)$ to $((a,1),e)$
\item $T(\eta_A);\mu_A=id_{T(A)}$ means $\mu_A((a,1),e) = (a,e)$, cf.\ $1*e=e$
\item $T(\mu_A);\mu_A = \mu_{T(A)};\mu_A$ cf.\ $(e*e')*e'' = e*(e'*e'')$
 \end{itemize}

 }


\frame
  {   
    \frametitle{The example was indeed a monad (one)}\label{Mon5:ExaMonadOne}

 \begin{itemize}[<+->]
\item The data in the example was: the category $\Set$, 
the functor $T:\Set\to\Set$ on slide \ref{Mon5:CatAbstrOne}, 
the natural transformation $\eta: id_\Set\To T$
defined by $\eta_X = unit_X$ on slide \ref{Mon5:CatAbstrTwo}, 
the natural transformation $\mu: T;T \To T$
on slide \ref{Mon5:CatAbstrThree}. Proofs of properties:
\item $\eta_{T(A)};\mu_A = id_{T(A)}$ means that  $(\eta_{T(A)};\mu_A)(a,m) = (a,m)$
for all $a\in A, m\in M$. Indeed $\mu_A(\eta_{T(A)}(a,m)) = \mu_A((a,m),1) =$ $= (a,1*m) = (a,m)$
by the left identity law in the monoid $M$
\item Exercise: verify  $id_{T(A)} = T(\eta_A);\mu_A$ using $T(f) = f\times id_M$
\item $T(\mu_A);\mu_A = \mu_{T(A)};\mu_A$ means that the two functions agree
on all $(a,m,m',m'')$ (flat notation). $T(\mu_A)$ and $\mu_{T(A)}$ give images $(a,m'*m,m'')$ and $(a,m,m''*m')$. Thereafter $\mu_A$ gives $(a,m''*(m'*m))$ and $(a,(m''*m')*m)$, which are equal by associativity in the monoid $M$.
 \end{itemize}

 }

\frame
  {   
    \frametitle{The example was indeed a monad (two)}\label{Mon5:ExaMonadTwo}

 \begin{itemize}[<+->]
\item We must also check that $\_^T, \Kc$ can be defined using $T,\eta,\mu$
 \begin{itemize}
\item $f^T = T(f);\mu_Y$ for all $f: X\to T(Y)$\footnote{Abstractly, here and below,
we use $f$ instead of $\Kp{f,p}:X\to T(Y)$}
\item $f \Kc  g = f ;T(g);\mu_Z$ for all $f: X\to T(Y)$, $g: Y\to T(Z)$
 \end{itemize}
\item The latter $\Kc$ is called \emph{Kleisli} composition, and is proved
associative, by using monad structure and properties only:\\
if also $h: Z\to T(A)$, then
$(f \Kc g) \Kc h = (f ;T(g);\mu_Z) \Kc h = f ;T(g);(\mu_Z; T(h)) ; \mu_A =
f ;T(g);(T^2(h);\mu_{T(A)}) ; \mu_A$ by naturality (exercise: draw the naturality diagram). 
Also, $f \Kc (g \Kc h) = f \Kc (g;T(h);\mu_A) = f; T(g;T(h);\mu_A);\mu_A =
f; T(g);T^2(h);(T(\mu_A);\mu_A) = f; T(g);T^2(h);(\mu_{T(A)};\mu_A)$
by functoriality and the \emph{monad associativity} law.

\item Exercise: verify all the steps in these proofs
 \end{itemize}

 }

\frame
  {   
    \frametitle{Monads in Haskell}\label{Mon5:MonadHask}

 \begin{itemize}[<+->]
\item $\HH$ is the \emph{syntactic category} of Haskell (types + functions)
\item The type of $\_^T$ is $(X\to T(Y)) \to (T(X)\to T(Y))$
\item In Haskell the arguments are swapped to obtain:
$$\bind : T(X) \to (X\to T(Y)) \to T(Y)~~\text{(pronounced \emph{bind}})$$
\item Interpretation: given $m:T(X)$ and $f: X\to T(Y)$, %to compute $(m\bind f):T(Y)$,
bind the argument of $f$ to the $X$-value $x$ of $m$ and compute $f(x)$;
the $Y$-value of $m\bind f$ is the $Y$-value of $f(x)$ and
the extra of $m\bind f$ is the $\_^T$-combination of 
the extras of $m$ and $f(x)$.
\item $\eta_X$ is called \ttt{return} in Haskell (a kind of misnomer),
the type subscript is left out as it can be inferred


 \end{itemize}

 }

\frame
  {   
    \frametitle{Monads in Haskell (ctnd)}\label{Mon5:MonadHaskCtnd}

 \begin{itemize}[<+->]
\item The monad laws now take the following (equivalent) form:
\begin{itemize}
    \item $((\ttt{return}\,a)\, \bind f) = f(a)$ (left unit law)
    \item $(m\, \bind \ttt{return}) = m$ (right unit law)
    \item $(m\, \bind f) \bind g = (m\, \bind \lambda x. (f(x) \bind g))$ (associativity)
 \end{itemize}
\item $\mu_X$ is definable by $\mu_X(m) = (m\bind id_{T(X)})$
\item The monad properties (laws) from slide \ref{Mon5:CatDefMonad} can be proved
\item Exercise (big): prove the equivalence of the monad laws in Haskell 
and in CT (slide \ref{Mon5:CatDefMonad})
 \end{itemize}

 }

\frame
  {   
    \frametitle{A simple mathematical example of a monad}\label{Mon5:PowSetMonad}

 \begin{itemize}[<+->]
\item The \emph{power set monad} consists of the following data:
 \begin{enumerate}
    \item the category $\Set$
    \item the functor $\powset:\Set\to\Set$, NB $\powset(f)(X) = f(X)$, the {\color{red}image}
    \item the natural transformation $\eta: id_\Set \To T$, $\eta_A(a)=\set{a}$
    \item the natural transformation $\mu$, 
$\mu_A: \powset(\powset(A)) \to \powset(A) $ defined by 
$\mu_A(X) = \bigcup X$ for all $X\subseteq\powset(A)$
 \end{enumerate}
%\item Exercise: figure out what $\mu_A$ does
\item The monad properties hold:
 \begin{enumerate}
    \item $\eta_{\powset(A)};\mu_A = id_{\powset(A)} = \powset(\eta_A);\mu_A$
    \item $\powset(\mu_A);\mu_A = \mu_{\powset(A)};\mu_A$
 \end{enumerate}
\item Proofs. 1. Let $X\subseteq A$, then $\eta_{\powset(A)}(X) = \set{X}$
and $\mu_A(\set{X}) = $ $ =\bigcup\set{X} = X$. 
Also, $\mu_A(\powset(\eta_A)(X)) = X$
since $\powset(\eta_A)(X)=$ $=\eta_A(X)=\set{\set{x} \mid x\in X}$. 
2. For $X\subseteq \powset^2(A)$, the {\color{red}image} 
$\mu_A(X) = \set{\mu_A(Y)\mid Y\in X}$
and $\mu_{\powset(A)}(X)=\bigcup X$. Applying $\mu_A$ gives
$\set{a\in A \mid \exists Z,Y~a\in Z\in Y \in X}$ for both (exercise).
 \end{itemize}

 }

\frame
  {   
    \frametitle{The list monad}\label{Mon5:ListMonad}

 \begin{itemize}[<+->]
\item The \emph{list monad} consists of the following data:
 \begin{enumerate}
    \item the category $\HH$ of Haskell types and functions
    \item the list functor $[\_]:\HH\to\HH$, NB\footnote%
{We avoid the ambiguous notation $[f]$, which could also have type $[A\to B]$,
whereas the intended type here is $[A]\to [B]$.}
 $[\_](f)  =  map\, f$
    \item the natural transformation $\eta: id_\HH \To \HH$, $\eta_A(a)= [a]$
    \item the natural transformation $\mu$, 
$\mu_A: [[A]] \to [A] $ defined by \emph{flattening}:
$\mu_A([]) = [],~\mu_A(l::ls) = l{+}\!{+}\mu_A(ls)$
 \end{enumerate}
%\item Exercise: figure out what $\mu_A$ does
\item The monad properties hold:
 \begin{enumerate}
    \item $\eta_{[A]};\mu_A = id_{[A]} = [\_](\eta_A);\mu_A$
    \item $[\_](\mu_A);\mu_A = \mu_{[A]};\mu_A$
 \end{enumerate}
\item Exercise: prove the above properties (compare with slide \ref{Mon5:PowSetMonad})
 \end{itemize}

 }

\frame
  {   
    \frametitle{The Maybe monad}\label{Mon5:ListMonad}

 \begin{itemize}[<+->]
\item The Maybe monad is useful for partial functions
\item The \emph{Maybe monad} consists of the following data:
 \begin{enumerate}
    \item the category $\HH$ of Haskell types and functions
    \item the functor \ttt{ data Maybe t = Just t | Nothing}, %($t$ a type variable)
 \ttt{Maybe(f)(Just a) = Just (f a), Maybe(f)(\_) = Nothing},
    \item the natural transformation $\eta: id_\HH \To \HH$, $\eta_A(a)= \ttt{Just a}$
    \item the natural transformation $\mu: \ttt{Maybe;Maybe} \to \ttt{Maybe}$, 
$\mu_A(\ttt{Just(Just(a))})= \ttt{Just(a)}$,  $\mu_A(\ttt{\_})= \ttt{Nothing}$
 \end{enumerate}
%\item Exercise: figure out what $\mu_A$ does
\item The monad properties hold:
 \begin{enumerate}
    \item $\eta_{[A]};\mu_A = id_\ttt{Maybe(A)} =\ttt{Maybe}(\eta_A);\mu_A$
    \item $\ttt{Maybe}(\mu_A);\mu_A = \mu_\ttt{Maybe(A)};\mu_A$
 \end{enumerate}
\item Exercise: prove the above properties
 \end{itemize}

 }

\end{document}

\myurl{en.wikipedia.org/wiki/Ordered_pair}
 \begin{itemize}
    \item emulation halts because of the partiality of $\delta$;
    \item emulation halts because of "head left" with head at first cell;
    \item emulation halts because of reaching a halting state;
    \item the emulated TM goes on forever.
 \end{itemize}
