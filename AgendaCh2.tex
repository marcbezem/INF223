\documentclass[handout]{beamer}
%\documentclass[slides]{beamer}
% Vary the color applet  (try out your own if you like)
%\colorlet{structure}{red!20!black}
%\beamertemplateshadingbackground{yellow!20}{white}
%\usepackage{beamerthemeshadow}
%\usepackage[utf8x]{inputenc} CONFLICT!
%\usepackage[english,norsk,nynorsk]{babel}
\usepackage{tikz}
\usetikzlibrary{trees}

\usepackage[all]{xy}
\usepackage{multicol}

%\setbeamertemplate{navigation symbols}{}++++++
%\setbeamertemplate{footline}[frame number]
\usetheme{Montpellier}


\input macros

\newcommand{\To}{\Rightarrow}
\newcommand{\Trt}{\stackrel{*}{\Rightarrow}}
\newcommand{\ToG}{\Rightarrow_G}
\newcommand{\redS}{{\color{red} S}}

\newcommand{\Set}{\mathsf{Set}}

\title[INF210 presentations]{}

\begin{document}

\section{Chapter 2}
\subsection{Directed Multigraphs}
 
\frame
  {   
    \frametitle{Directed Multigraphs}\label{Ch2:DMG}

 \begin{itemize}[<+->]
\item A directed multigraph $G$ consists of the following data:
   \begin{itemize}[<+->]
\item A collection $G_V$ of vertices (also called nodes)
\item A collection $G_E$ of (directed) edges (also called arrows)
\item A function $sc^G : G_ E \to G_V$ called the source function
\item A function $tg^G : G_ E \to G_V$ called the target function
   \end{itemize}
\item Any $f:G_E$ is an arrow from node $sc^G(f)$ to node $tg^G(f)$
\item We also write $f:v\to u$ and $v \stackrel{f}{\to} u$ to express
that $sc^G(f)=v$ and $tg^G(f)=u$, colloquially  "from $v$ to $u$"
\item Graphs are abundant in CS (un/directed, multi-, labelled, ...)
\item Simple graphs: at most one edge $f:v\to u$, for any $v,u\in G_ V$
\item For simple graphs we can put $G_ E \subseteq G_V\times G_V$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Examples of  directed multigraphs}\label{Ch2:DMGexamples}

 \begin{itemize}[<+->]
\item Several examples from the script on Whiteboard
\item As we will see, categories are directed multigraphs + ...
\item With/out decoration: class diagrams, flow charts, state transition systems,
entity relationship diagrams, ...
\item Successor relation on $\nat$: $0\to 1,~1\to 2,~2\to 3,\ldots$
\item Any binary relation on a set forms a simple graph
\item (span) $A\stackrel{\pi_1}{\leftarrow} A\times B \stackrel{\pi_1}{\to} B$,
(cospan) $A\stackrel{\kappa_1}{\to} A\uplus B \stackrel{\kappa_1}{\leftarrow} B$
\item A (large) multigraph: nodes are sets, arrrows are functions $f:A\to B$,
with $A,B$ sets
 \end{itemize}

 }

\frame
  {   
    \frametitle{Graph Operations}\label{Ch1:GraphOps}

 \begin{itemize}[<+->]
\item Nice intro in script: working on a graph as an abstract software model
\item At some moment in time we have graph $G$, what next?
   \begin{enumerate}[<+->]
\item Add nodes and/or arrows and get a `supergraph' $H$ (provided all new edges
have source and target)
\item Delete nodes and/or arrows and get a `subgraph'
(delete all arrows `orphaned' by deleting nodes)
\item Rename nodes and/or arrows, and get an `isomorphic' graph
\item Collapse (make equal) nodes and/or arrows, taking care we get a graph
($f=g$ only if $f,g: u\to v$)
   \end{enumerate}
\item Examples on Whiteboard, illustrating the many different cases
 \end{itemize}

 }

\frame
  {   
    \frametitle{Graph Homomorphisms}\label{Ch1:GraphHoms}

 \begin{itemize}[<+->]
\item The operations on the previous slide lead to two new notions:
 \begin{itemize}[<+->]
\item $G\sqsubseteq H$ (sub/super graph) if $G_V\subseteq H_V$, $G_E\subseteq H_E$,
and for all $f: v\to u$ in $G$ we have $f: v\to u$ in $H$
\item $\varphi: G\to H$ graph homomorphisme if $\varphi$ maps nodes to nodes and arrows
to arrows such that for all $f: v\to u$ in $G$ we have $\varphi(f): \varphi(v)\to \varphi(u)$ in $H$
 \end{itemize}
\item Trivial example: the identity graph homomorphism $G\to G$
\item Actually, for all graphs $G,H$ with $G_V \subseteq H_V$ and $G_E \subseteq H_E$, 
$G$ is a subgraph of $H$
iff the two inclusion maps together form a homomorphism
\item $\varphi: G\to H$ is a graph isomorphism if $\varphi$ is a graph
homomor- phism and there is  a graph homomorphism $\psi: H\to G$ such that
$\varphi\circ\psi$ and $\psi\circ\varphi$ are identity maps (cf.\ renaming above) 
 \end{itemize}

 }


\frame
  {   
    \frametitle{Opposite graph}\label{Ch1:oppgraph}

 \begin{itemize}[<+->]
\item Given a graph $G$, the opposite graph $G^{opp}$ has the same nodes
and arrows, but the directions of all arrows is reversed
\item This boils down to interchanging the $sc$ and $tg$ functions
%\item Examples: the opposite of a span is a cospan;  the opposite of a cospan is a span
\item Clearly: ${G^{opp}}^{opp} = G$
\item NB1: $(b \stackrel{c}{\leftarrow} a) = (a \stackrel{c}{\to} b) \neq  
(b \stackrel{c}{\to} a) = (a \stackrel{c}{\leftarrow} b) $
if $a\neq b$
\item NB2: As graphs with two nodes and one arrow, ${a \stackrel{c}{\to} b}$
and ${b \stackrel{c}{\to} a}$ are each other's opposite, and happen to be isomorphic
\item NB3: opposite graphs need not be isomorphic in general, e.g., the span
${b \stackrel{c}{\leftarrow} a}\stackrel{d}{\to}a$ is not isomorphic to its cospan if $a\neq b$
\item Elaboration on Whiteboard
 \end{itemize}

 }

\section{Chapter 2}
\subsection{Categories}


\frame
  {   
    \frametitle{Compostion and identities}\label{Ch2:comp-id}

 \begin{itemize}[<+->]
\item Two notations of composition of maps $f:A\to B$ and $g: B\to C$,
both denoting the same map $A\to C$:
   \begin{itemize}[<+->]
\item Applicative order: ${g\circ f} : {A\to C}$ reflecting $a\mapsto g(f(a))$
\item Diagram order: ${f;g} : A\to C$ reflecting $A\stackrel{f}{\to}B\stackrel{g}{\to}C$
   \end{itemize}
\item 
 \end{itemize}

 }

\frame
  {   
    \frametitle{Comments on script}\label{Ch2:comments}

 \begin{itemize}[<+->]
\item p. 19, Cor. 2.1.15: $in_V = in_{G_V,H_V}$, $in_E = in_{G_E,H_E}$
\item p. 29, Conv. 2.2.13: $C_V$ must be $C_E$ (twice)
\item p. 29, Rem. 2.2.15: in Haskell and type theory, composition would be
\emph{one} polymorphic function with type arguments $A,B,C$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Comments on script}\label{Ch1:comments}

 \begin{itemize}[<+->]
\item p. 19, Cor. 2.1.15: $in_V = in_{G_V,H_V}$, $in_E = in_{G_E,H_E}$
\item p. 29, Conv. 2.2.13: $C_V$ must be $C_E$ (twice)
\item p. 29, Rem. 2.2.15: in Haskell and type theory, composition would be
\emph{one} polymorphic function with type arguments $A,B,C$
 \end{itemize}

 }

\end{document}

\myurl{en.wikipedia.org/wiki/Ordered_pair}
 \begin{itemize}
    \item emulation halts because of the partiality of $\delta$;
    \item emulation halts because of "head left" with head at first cell;
    \item emulation halts because of reaching a halting state;
    \item the emulated TM goes on forever.
 \end{itemize}
