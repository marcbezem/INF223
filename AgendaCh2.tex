\documentclass[handout]{beamer}
%\documentclass[slides]{beamer}
% Vary the color applet  (try out your own if you like)
%\colorlet{structure}{red!20!black}
%\beamertemplateshadingbackground{yellow!20}{white}
%\usepackage{beamerthemeshadow}
%\usepackage[utf8x]{inputenc} CONFLICT!
%\usepackage[english,norsk,nynorsk]{babel}
\usepackage{tikz}
\usepackage{tikz-cd} 
\usetikzlibrary{trees}

\usepackage[all]{xy}
\usepackage{multicol}

%\setbeamertemplate{navigation symbols}{}++++++
%\setbeamertemplate{footline}[frame number]
\usetheme{Montpellier}
\setbeamertemplate{footline}[frame number]


\input macros

\newcommand{\To}{\Rightarrow}
\newcommand{\Trt}{\stackrel{*}{\Rightarrow}}
\newcommand{\ToG}{\Rightarrow_G}
\newcommand{\redS}{{\color{red} S}}

\newcommand{\bfsf}[1]{{\boldsymbol{#1}}}
\newcommand{\Set}{\bfsf{Set}}
\newcommand{\Gra}{\bfsf{Graph}}
\newcommand{\CC}{\bfsf{C}}
\newcommand{\DD}{\bfsf{D}}
\newcommand{\EE}{\bfsf{E}}
\newcommand{\PP}{\bfsf{P}}
\newcommand{\Nat}{\bfsf{Nat}}
\newcommand{\Incl}{\bfsf{Incl}}
\newcommand{\Rel}{\bfsf{Rel}}
\newcommand{\Mult}{\bfsf{Mult}}
\newcommand{\Mon}{\bfsf{Mon}}
\newcommand{\Cat}{\bfsf{Cat}}
\newcommand{\CAT}{\bfsf{CAT}}


\title[INF223 presentations]{}

\begin{document}

\section{Chapter 2}
\subsection{Directed Multigraphs}
 
\frame
  {   
    \frametitle{Directed Multigraphs}\label{Ch2:DMG}

 \begin{itemize}[<+->]
\item A (directed multi) \emph{graph} $G$ consists of the following data:
   \begin{itemize}[<+->]
\item A collection $G_V$ of vertices (also called nodes)
\item A collection $G_E$ of (directed) edges (also called arrows)
\item A function $sc^G : G_ E \to G_V$ called the source function
\item A function $tg^G : G_ E \to G_V$ called the target function
   \end{itemize}
\item Any $f:G_E$ is an arrow from node $sc^G(f)$ to node $tg^G(f)$
\item We also write $f:v\to u$ and $v \stackrel{f}{\to} u$ to express
that $sc^G(f)=v$ and $tg^G(f)=u$, colloquially  "from $v$ to $u$"
\item Graphs are abundant in CS (un/directed, multi-, labelled, ...)
\item Simple graphs: at most one edge $f:v\to u$, for any $v,u\in G_ V$
\item For simple graphs we can put $G_ E \subseteq G_V\times G_V$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Examples of  directed multigraphs}\label{Ch2:DMGexamples}

 \begin{itemize}[<+->]
\item Several examples from the script on Whiteboard
\item As we will see, categories are directed multigraphs + extras
\item With/out decoration: class diagrams, flow charts, state transition systems,
entity relationship diagrams, ...
\item Successor relation on $\nat$: $0\to 1,~1\to 2,~2\to 3,\ldots$
\item Any binary relation on a set forms a simple graph
\item (span) $A\stackrel{\pi_1}{\leftarrow} A\times B \stackrel{\pi_2}{\to} B$,
(cospan) $A\stackrel{\kappa_1}{\to} A\uplus B \stackrel{\kappa_2}{\leftarrow} B$
\item A (large) multigraph: nodes are sets, arrrows are functions $f:A\to B$,
with $A,B$ sets
 \end{itemize}

 }

\frame
  {   
    \frametitle{Graph Operations}\label{Ch2:GraphOps}

 \begin{itemize}[<+->]
\item Nice intro in script: working on a graph as an abstract software model
\item At some moment in time we have graph $G$, what next?
   \begin{enumerate}[<+->]
\item Add nodes and/or arrows and get a `supergraph' $H$ (provided all new edges
have source and target)
\item Delete nodes and/or arrows and get a `subgraph'
(delete all arrows `orphaned' by deleting nodes)
\item Rename nodes and/or arrows, and get an `isomorphic' graph
\item Collapse (make equal) nodes and/or arrows, taking care we get a graph
($f=g$ only if $f,g: u\to v$)
   \end{enumerate}
\item Examples on Whiteboard, illustrating the many different cases
 \end{itemize}

 }

\frame
  {   
    \frametitle{Graph Homomorphisms}\label{Ch2:GraphHoms}

 \begin{itemize}[<+->]
\item The operations on the previous slide lead to two new notions:
 \begin{itemize}[<+->]
\item $G\sqsubseteq H$ (sub/super graph) if $G_V\subseteq H_V$, $G_E\subseteq H_E$,
and for all $f: v\to u$ in $G$ we have $f: v\to u$ in $H$
\item $\varphi: G\to H$ graph homomorphisme if $\varphi$ maps nodes to nodes and arrows
to arrows such that for all $f: v\to u$ in $G$ we have $\varphi(f): \varphi(v)\to \varphi(u)$ in $H$
 \end{itemize}
\item Example: the identity graph homomorphism $id_G : G\to G$
\item Actually, for all graphs $G,H$ with $G_V \subseteq H_V$ and $G_E \subseteq H_E$, 
$G$ is a subgraph of $H$
iff the two inclusion maps together form a homomorphism
\item $\varphi: G\to H$ is a graph isomorphism if $\varphi$ is a graph
homomor- phism and there is  a graph homomorphism $\psi: H\to G$ such that
$\varphi\circ\psi$ and $\psi\circ\varphi$ are identity maps (cf.\ renaming above) 
 \end{itemize}

 }


\frame
  {   
    \frametitle{Opposite graph}\label{Ch2:oppgraph}

 \begin{itemize}[<+->]
\item Given a graph $G$, the opposite graph $G^{opp}$ has the same nodes
and arrows, but the directions of all arrows is reversed
\item This boils down to interchanging the $sc$ and $tg$ functions
%\item Examples: the opposite of a span is a cospan;  the opposite of a cospan is a span
\item Clearly: ${G^{opp}}^{opp} = G$
\item NB1: $(b \stackrel{c}{\leftarrow} a) = (a \stackrel{c}{\to} b) \neq  
(b \stackrel{c}{\to} a) = (a \stackrel{c}{\leftarrow} b) $
if $a\neq b$
\item NB2: As graphs with two nodes and one arrow, ${a \stackrel{c}{\to} b}$
and ${b \stackrel{c}{\to} a}$ are each other's opposite, and happen to be isomorphic
\item NB3: opposite graphs need not be isomorphic in general, e.g., the span
${b \stackrel{c}{\leftarrow} a}\stackrel{d}{\to}a$ is not isomorphic to its cospan if $a\neq b$
\item Elaboration on Whiteboard
 \end{itemize}

 }


\subsection{Categories}


\frame
  {   
    \frametitle{Composition and identities in set theory}\label{Ch2:comp-id}

 \begin{itemize}[<+->]
\item For all maps $f:A\to B$ and $f':A\to B$ we have $f=f'$ if $f(a)=f'(a)$ for all $a\in A$
\item Two notations of composition of maps $f:A\to B$ and $g: B\to C$,
both denoting the same map $A\to C$:
   \begin{itemize}[<+->]
\item Applicative order: ${g\circ f} : {A\to C}$ reflecting $a\mapsto g(f(a))$
\item Diagrammatric order: ${f;g} : A\to C$ reflecting $A\stackrel{f}{\to}B\stackrel{g}{\to}C$
   \end{itemize}
\item The original sin here is the convention to write the function before its argument
instead of after: $f(a)$ instead of $af$,
while at the same time reading from left to right
\item Anyway: $f;(g;h) = (f;g);h$, and so $h\circ(g\circ f) = (h\circ g)\circ f$,
for all $A\stackrel{f}{\to}B\stackrel{g}{\to}C\stackrel{h}{\to}D$
\item Also: $id_A ; f = f$ and $f; id_B = f$ for all $f:A\to B$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Composition of graph homomorphisms}\label{Ch2:Ghom-comp}

 \begin{itemize}[<+->]
\item A graph homomorphism $\varphi: G\to H$ is a pair of maps
$\varphi_V : G_V \to H_V$ and $\varphi_E : G_E \to H_E$ preserving graph structure 
\item Similarly, a graph homomorphism $\psi: H\to K$ is a pair of maps
$\psi_V : H_V \to K_V$ and $\psi_E : H_E \to K_E$ preserving graph structure
\item Define $\varphi;\psi$ to be the pair of $\varphi_V;\psi_V$ and $\varphi_E;\psi_E$
\item Then: $\varphi;\psi$ is a graph homomorphism $G\to K$
\item Proof is spelled out in detail in the script
\item A lighter touch: if $f: v\to u$ in $G$, 
then $\varphi(f): \varphi(v)\to \varphi(u)$ in $H$
since $\varphi$ is a graph homomorphism $G\to H$, 
hence we have $\psi(\varphi(f)): \psi(\varphi(v))\to \psi(\varphi(u))$ in $K$
since $\psi$ is a graph homomorphism $H\to K$, 
which is what we need 
%$\varphi;\psi(f)): \varphi;\psi(v))\to \varphi;\psi(u))$ in $K$
\item Also: $id_G ; \varphi = \varphi$ and $\varphi; id_H = \varphi$ for all $\varphi:G\to H$
 \item Also: associativity $\varphi;(\psi;\rho) = (\varphi;\psi);\rho$
 \end{itemize}

 }


\frame
  {   
    \frametitle{Categories}\label{Ch2:categories}

 \begin{itemize}[<+->]
\item A category $\CC = (\CC_V,\CC_E,sc^\CC, tg^\CC, id^\CC,(\_;^\CC\_))$ consists of the following data:
   \begin{enumerate}[<+->]
\item A graph $gr(\CC) =  (\CC_V,\CC_E,sc^\CC, tg^\CC)$ where nodes are now also called objects
and arrows also morphisms
\item A (partial) composition operation $(\_;\_)$ mapping $f: A\to B$, $g: B\to C$
to $(f;g): A\to C$, for all objects $A,B,C$
\item A map $id^\CC$ mapping any object $A$ to a morphism $id^\CC_A: A\to A$
   \end{enumerate}
satisfying the identity laws and the associativity law:
   \begin{itemize}[<+->]
\item(ID) if $f: A\to B$, then $id^\CC_A;f = f$ and  $f;id^\CC_B = f$
\item(ASS) if $A \stackrel{f}{\to} B \stackrel{g}{\to} C \stackrel{h}{\to}D $, then $f;(g;h)=(f;g);h$
   \end{itemize}
\item NB $\CC \neq C$, we may omit superscripts $\CC$,
we write $\CC(A,B)$ for the collection of morphisms $A\to B$
\item Indentities are uniquely determined by the identity laws
 \end{itemize}

 }

\frame
  {   
    \frametitle{Examples of Categories}\label{Ch2:ExaCat}

 \begin{itemize}[<+->]
\item Haskell (idealized), with types as objects and functions as morphisms, 
the polymorphic identity function and polymorphic \myurl{https://wiki.haskell.org/Function_composition}
\item $\Set$ with sets as objects, functions as morphisms,
$id_A: A\to A$ the identity function, and ``$;$'' as on slide \ref{Ch2:comp-id}
\item $\Gra$ with graphs as objects, graph homomorphisms as morphisms,
$id_G: G\to G$ the identity graph homomorphism on slide \ref{Ch2:GraphHoms}, 
and composition ``$;$' on slide \ref{Ch2:Ghom-comp}
\item Cartesian product, coproduct and epi-mono factorization are additional
features that a category may/not have. For example, $\Set$ with only injections,
with only surjections, or with only bijections are all three categories, but
with different features (see next slide)
 \end{itemize}

 }

\frame
  {   
    \frametitle{More Examples of Categories}\label{Ch2:MoreExaCat}

 \begin{itemize}[<+->]
\item Sets with injections ($A\times B \stackrel{\pi_1}{\to} A$ is not always injective)
\item Sets with surjections ($ A\stackrel{\kappa_1}{\to} A\uplus B$ is not always surjective)
\item Sets with bijections (both problems)
\item One set $A$ with all maps $A\to A$ forms a category $\mathsf{A}$
which does not satisfy epi-mono factorization if $A$ contains more than one element
\item A category is called small if the collections of objects and morphisms are sets, 
and locally small if $\CC(A,B)$ is a set for all objects $A,B$
\item Examples: $\mathsf{A}$ is both small and locally small, $\Set$ is only locally small,
but not small, since there is no set of all sets
 \end{itemize}
 }

\frame
  {   
    \frametitle{Isomorphisms}\label{Ch2:Isos}

 \begin{itemize}[<+->]
\item A morphism $f : A\to B$ in a category $\CC$ is called an iso (isomorphism)
if there exists a morphism $g : B\to A$ such that $f;g = id^\CC_A$ and
$g;f = id^\CC_B$
\item If it exists, the morphism $g$ above is called the inverse of $f$
\item If $g$ is the inverse of $f$, then $g$ is unique: if $g'$ is also
an inverse of $f$, then $g = id_B;g = (g';f);g = g';(f;g) = g';id_A = g'$.
\item Examples: in any category, $id_A$ is an iso and $id_A^{-1} = id_A$;
in $\Set$, iso = bijection; in $\Gra$, iso = graph isomorphism
\item If there is an iso $f: A\to B$, we call $A$ and $B$ isomorphic, 
denoted $A\simeq B$
\item If  $A \stackrel{f}{\to} B \stackrel{g}{\to} C$ and $f,g$ are isos, then
$f;g$ is iso and $(f;g)^{-1} = g^{-1}; f^{-1}$
(Proof on Whiteboard, add loop $id_B$)
 \end{itemize}

 }

\frame
  {   
    \frametitle{Even More Examples of Categories}\label{Ch2:evenMoreExaCat}

 \begin{itemize}[<+->]
\item The empty category: no objects, and hence no morphisms
\item Discrete categories: only identity morphisms, $\bfsf{n}$ denotes
the discrete category with $n$ objects (later: names don't matter)
\item Finite categories and pictorial diagrams: WYSIWYG?
\item Complete underlying graph: WYSCanBeWrong, WYSIAllYG (objects and morphisms,
extra info may be needed for ;)
\item Several examples on Whiteboard
\item Really nice: 2.2.5, exercise 5
 \end{itemize}

 }


\subsection{Sets and Relations}

\frame
  {
    
    \frametitle{Binary Relation Therapy (after MNF130)}\label{Ch2:BinRels}

 \begin{itemize}[<+->]\label{right-left-invariance}
    \item Binary relation $R$ is an \emph{equivalence} on a set $S$ if:
    \begin{itemize}[<+->]
    \item $R$ is \emph{reflexive}: $\forall x\in S~(xRx)$, and
    \item $R$ is \emph{symmetric}: $\forall x,y\in S~(xRy \implies yRx)$, and
    \item $R$ is \emph{transitive}: $\forall x,y,z\in S~(xRy \wedge yRz \implies xRz)$.
    \end{itemize}
    \item Any equivalence relation $R$ on $S$ \emph{partitions} $S$ 
    in \emph{classes} $[x]_R = \set{y \mid xRy}$; 
    the \emph{quotient} is $S/R = \set{[x]_R \mid x\in S}$
    \item Binary relation $R$ on $S$ is
    \begin{itemize}[<+->]
     \item a \emph{preorder} if $R$ is reflexive and transitive
     \item a \emph{partial order} if $R$ is a preorder and antisymmetrisk:
     $\forall x,y\in S~(xRy \wedge yRx \implies x=y)$
     \item a \emph{(total) order} if $R$ is a partial order and total:
     $\forall x,y\in S~(xRy \vee yRx)$
    \end{itemize}
 \end{itemize}

}

\frame
  {
    
    \frametitle{Binary Relation Therapy (ctnd)}\label{Ch2:BinRelsCtnd}

 \begin{itemize}[<+->]\label{right-left-invariance}
    \item Examples
    \begin{itemize}[<+->]
    \item total order: $\leq$ on a set of numbers
    \item partial order: $\subseteq$ on a collection of  sets 
    \item preorder: $\sqsubseteq$ on a set of persons defined by age comparison
%$p\sqsubseteq p'$  if $p'$ is older than $p$
    \end{itemize}
    \item Any equivalence relation $R$ on $S$ \emph{partitions} $S$ 
    in \emph{classes} $[x]_R = \set{y \mid xRy}$; 
    the \emph{quotient} is $S/R = \set{[x]_R \mid x\in S}$
    \item Example of the an equivalence relation: let $R$ be a preorder
and define $p\simeq p'$ if $(p R p' \wedge p' R p)$. Then $\simeq$ is an equivalence
relation. In the case of $R$ being ${\sqsubseteq}$ above, we have that  
$[p]_\simeq = \set{p' \mid p\simeq p'}$  is the age class of $p$. Moreover,
we can define a relation $[R]$ on classes by $[p]\,[R]\, [q] $ if $pRq$ (why?).
The relation $[R]$ is a partial order on the classes, 
explaining why $R$ is called preorder. Age classes are even totally ordered.
 \end{itemize}

}

\frame
  {   
    \frametitle{Subcategories}\label{Ch2:Subcategories}

 \begin{itemize}[<+->]
\item A saying: in CT all things that ought be true are in fact true
\item Since a category is a graph + extras (id, ``;'', ID, ASS), a subcategory is ...
indeed a subgraph with the extras coming from the category
\item A category $\DD$ is  a subcategory of a category $\CC$ if 
   \begin{enumerate}[<+->]
\item $gr(\DD) \sqsubseteq gr(\CC)$, i.e., $gr(\DD)$ is a subgraph of $gr(\CC)$
\item $id^\DD_A =  id^\CC_A$ for all objects $A$ of $\DD$
\item $(f;^\DD g) =(f;^\CC g)$ for all  objects $A,B,C$ of $\DD$ and $f\in\DD(A,B)$, $g\in\DD(B,C)$
   \end{enumerate}
\item Equivalent definition of subcategory:
$\DD_V\subseteq \CC_V$ and $\DD_E\subseteq \CC_E$  and $\DD_V,\DD_E$
are closed under $sc^\CC,tg^\CC, ;^\CC, id^\CC$
\item Examples on next slide
 \end{itemize}

 }

\frame
  {   
    \frametitle{Ever More Examples of Categories}\label{Ch2:everMoreExaCat}
 \begin{itemize}[<+->]
\item The category $\Incl$: maps $in_{A,B} :A\to B$ if $A\subseteq B$ ($A,B$ sets)
\item The category $\Nat$: one morphism $n\to m$ if $n\leq m$  ($n,m\in\nat$)
\item The category $\bfsf{Pow}(S)$: small subcategory of $\Incl$ with object
set $\powset{S}$, given some fixed but arbitrary set $S$
\item More general: preorder category and partial order category
\item The category $\Rel$: morphisms $R\subseteq A\times B$ ($A,B$ sets),
composition of relations (DBs: join!), $id_A = \set{(a,a)\mid a\in A}$
\item Subcategory of $\Rel$: morphisms $A\to B$ are partial functions
(a partial function may leave $f(a)$ undefined)
 \end{itemize}

 }


\frame
  {   
    \frametitle{More Basics on Sets}\label{Ch2:SetBasics}


 \begin{itemize}[<+->]
    \item Binary relation $R\subseteq A\times B$ from $A$ to $B$ is
    \begin{itemize}[<+->]
    \item \emph{total} if  $\forall a\in A~\exists b\in B~(aRb)$ (alt-not.: $(a,b)\in R$, $R(a,b)$)
    \item \emph{single-valued} if  $\forall a\in A,~b,b'\in B~(aRb \wedge aRb' \implies b=b')$
    \item a \emph{partial function} if  $R$ is single-valued
    \item a \emph{(total) function} if  $R$ is single-valued and total
    \end{itemize}
   \item If $R\subseteq A\times B$ and $S\subseteq B\times C$ then their \emph{composition}          
     $R;S$ is \[\set{(a,c) \mid \exists b\in B~(aRb\wedge bSc)}\subseteq A\times C\]
    \item The notion of composition of relations is compatible with that of partial and
     total function (in ZF set theory, the latter two are defined by the former);
     associativity everywhere!
    \item NB Composition of partial functions is \emph{strict}, $f(a)=b$ and $g(b)=c$ must exist
          in order to get $g(f(a))=c$
    \item Lazy Haskell is not strict: try $(fun~x\mapsto 0)(1/0)$
 \end{itemize}

}

\frame
  {   
    \frametitle{The Category of Multimaps}\label{Ch2:Multimaps}
 \begin{itemize}[<+->]
\item Binary relation $R\subseteq A\times B$ from $A$ to $B$  can also be seen as 
\begin{itemize}[<+->]
\item a \emph{multimap} $\rho_R$ from $A$ to $B$ which is
actually an ordinary map  $\rho_R : A\to \powset{B}$, 
defined by $\rho_R(a) = \set{b\in B\mid R(a,b)}$, and as a
\item a \emph{multimap} $\lambda_R$ from $B$ to $A$ which is
actually an ordinary map  $\lambda_R : B\to \powset{A}$, 
defined by $\lambda_R(b) = \set{a\in A\mid R(a,b)}$
\end{itemize}
\item Conversely, any $f : X\to \powset{Y}$ defines a relation $R_f$ from $X$ to $Y$
defined by $xR_f y$ if $y\in f(x)$
\item In fact, we have bijections ($R^c = \set{(b,a)\mid (a,b)\in R}$)
\begin{itemize}[<+->]
\item between $\powset(A\times B)$ and $A\to \powset{B}$: $R_{\rho_R} = R$ and 
$\rho_{R_f} = f$
\item between $\powset(A\times B)$ and $\powset(B\times A)$: $R\mapsto R^c$
\item between $\powset(A\times B)$ and $B\to \powset{A}$: $R_{\lambda_R} = R^c$ and $\lambda_{R^c_g} = g$
 \end{itemize}
\item The category $\Mult$ has sets as objects and multimaps as morphisms,
with identity morphisms and composition as spelled out in the script 
 \end{itemize}

 }

\frame
  {   
    \frametitle{Composition of multimaps}\label{Ch2:compmultimap}

 \begin{itemize}[<+->]
\item Let $f : A\to \powset{B}$ and $g : B\to \powset{C}$ and
recall $aR_fb = (b\in f(a))$ and $bR_g c = (c\in g(b))$
\item Recall $(R_f;R_g) = \set{(a,c) \mid \exists b\in B~(aR_fb\wedge bR_gc)}\subseteq A\times C$
\item Hence $(R_f;R_g) = \set{(a,c) \mid \exists b\in B~(b\in f(a)\wedge c\in g(b))}$
\item So $(R_f;R_g) = \set{(a,c) \mid c\in \bigcup \set{g(b)\mid b\in f(a)}}$
\item Define $(f;^\Mult g) = \set{(a,c) \mid c\in \bigcup \set{g(b)\mid b\in f(a)}}$
\item Define $id^\Mult_A: A\to \powset(A)$ by $id^\Mult_A(a) = \set{a}$ for all $a\in A$
\item Then $R_{id^\Mult_A}$ is ... $\Delta_A = \set{(a,a)\mid a\in A }$
\item ID and ASS for $\Mult$ are inherited from $\Rel$
 \end{itemize}

 }


\subsection{More on Graphs}

\frame
  {   
    \frametitle{Simple and ordinary graphs}\label{Ch2:oGraph}

 \begin{itemize}[<+->]
\item Recall \emph{simple} graph $G$: at most one arrow per $(v,u)\in G_V^2$
\item Recall \emph{canonical} graph $G$:  $G_E\subseteq G_V^2$, $sc=in{;}\pi_1$, $tg=in{;}\pi_2$
\item Now: \emph{ordinary} graph $G$:  $G_V$ a set, $G_E\subseteq G_V^2$
\item Homomorphism $\varphi: G\to H$ of ordinary graphs: map $\varphi: G_V\to H_V$
such that $(\varphi(v),\varphi(u))\in H_E$ for all $(v,u)\in G_E$
\item Tempting but wrong: an iso is a bijective homomorphism
\item Wrong since $H$ can have more arrows than $G$
\item Correct: an iso is a bijective homomorphism whose inverse is also a homomorphism
\item Also correct (script): $(v,u)\in G_E$ iff $(\varphi(v),\varphi(u))\in H_E$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Reflexive graphs}\label{Ch2:rGraph}

 \begin{itemize}[<+->]
\item This is an example how adding structure changes the notion of homomorphism
(of course, since that concept is about preserving structure)
\item A \emph{reflexive} graph $G$ is a graph plus a function $id^G : G_V \to G_E$
such that $id^G(A): A \to A$ for all nodes $A\in G_V$
\item A homomorphism $\varphi: (G,id^G)\to (H,id^H)$ of reflexive graphs
is a graph homomorphism $\varphi: G\to H$ such 
that $\varphi_E(id^G(A)) = id^H(\varphi_V(A))$ for all nodes $A$ of $G$
\item Composition and identity reflexive graph homomorphisms as expected,
yielding a category of reflexive graphs
 \end{itemize}

 }

\subsection{Monoids}


\frame
  {   
    \frametitle{Monoids in CT}\label{Ch2:CTMonoid}

 \begin{itemize}[<+->]
\item CTheorist: \\a \emph{monoid} is a locally small category with one object
 \end{itemize}

 }

\frame
  {   
    \frametitle{Monoids}\label{Ch2:Monoid}

 \begin{itemize}[<+->]
\item A \emph{monoid} $M=(M,c^M,b^M)$ consists of the following data:
   \begin{itemize}[<+->]
\item A set $M$, called the \emph{carrier} (notation!)
\item An element $c^M \in M$ called the \emph{neutral} element or \emph{unit}
\item A binary operation $b^M : (M\times M) \to M$
   \end{itemize}
satisfying the identity laws ID and associativity ASS
\item Examples of monoids with carrier set, unit and operation:   
\begin{itemize}[<+->]
\item Natural numbers with 0 and + (also other sets of numbers)
\item Natural numbers with 1 and * (also other sets of numbers)
\item Lists with $[]$ and concatenation $\oplus$ (over any set of elements)
\item Sets with $\emptyset$ and union $\cup$ (any powerset of a set)
\item Maps $X\to X$ with $id_X$ and composition $\circ$ (any set $X$)
   \end{itemize}
 \end{itemize}

 }

\frame
  {   
    \frametitle{Monoid Homomorphism}\label{Ch2:MonoidHom}

 \begin{itemize}[<+->]
\item For monoids $M,N$, a monoid homomorphism $f: M\to N$ is a
map (of the carrier sets) such that $f(c^M) = c^N$ and $f(b^M(x,y)) = b^N(f(x),f(y))$ for all $x,y\in M$
\item Example: $length : ([A],[],\oplus) \to (\nat,0,{+})$, for any set $A$
\item Submonoid: $M\subseteq N$ and $in_{M,N}: M\to N$ a monoid homomorphism
\item Alternatively: $N$ a monoid and $M$ a \emph{closed subset} $M\subseteq N$,
where closed \emph{here} (cf. subgraph) means: $c^N \in M$ and $b^N(x,y)\in M$ if $x,y\in M$
\item Example:  $([A],[],\oplus)$ is a submonoid of  $([B],[],\oplus)$, for any sets $A\subseteq B$
\item Haskell: $map~f: [A] \to [B]$ is a monoid 
homomorphism for any $f: A\to B$ (recall in Haskell $map~f~[] = []$ and $map~f~(a:as) =$ 
$ f~a : map~f~as$)
 \end{itemize}

 }

\frame
  {   
    \frametitle{More examples of Monoids}\label{Ch2:ExaMonoid}

 \begin{itemize}[<+->]
\item Any locally small category $\CC$ with one object $\bullet$ is a 
monoid with carrier set $\CC(\bullet,\bullet)$, unit $id_\bullet$ and composition
of morphisms %(by ID and ASS)
\item The \emph{unit monoid} is the discrete category with one object
\item For any set $A$, $\powfin A$ is a submonoid of $({\powset} A,\emptyset,{\cup})$
\item Given a monoid $M=(M,c,b)$ and a set $X$, we can define a monoid 
$(X\to M , c^{X\to M}, b^{X\to M})$:
   \begin{itemize}[<+->]
\item the unit of $X\to M$ is the function $c^{X\to M}(x) =c$ for all $x\in X$
\item given $f,g: X\to M$, we define $b^{X\to M}(f,g)(x) = b(f(x),g(x))$ for all $x\in X$
\item ID and ASS are inherited from the monoid $M$
   \end{itemize}
\item The above construction gives us several interesting monoids, old and new:
   \begin{itemize}[<+->]
\item $(\powset A,\emptyset,{\cup})$ by taking $M= ...$ (exercise) 
\item The monoid of multisets  over $X$, by taking $M=(\nat,0,{+})$
   \end{itemize}
 \end{itemize}

 }

\frame
  {   
    \frametitle{The Category of Monoids}\label{Ch2:CatMon}

 \begin{itemize}[<+->]
\item Composition of monoid homomorphisms is just composition of them as maps
(this preserves monoid structure and is associative)
\item The identity monoid homomorphisms is just the identity map 
(trivially preserving monoid structure and satisfying the identity laws)
\item The category $\Mon$ has monoids as objects and monoid homomorphisms
 as morphisms, with identity morphisms and composition as above
\item An iso in $\Mon$ is a bijective monoid  homomorphism (the inverse
is then automatically also a monoid  homomorphism) 
\item Examples: $([\set{|}],[],\oplus) \simeq (\nat,0,{+})$, 
$({\powset}{\set{0}},\emptyset,{\cup}) \simeq (\set{0,1},0,{\max})$,
$({\powset}{\set{0}},\set{0},{\cap}) \simeq (\set{0,1},1,{\min})$

 \end{itemize}

 }

\frame
  {   
    \frametitle{The free monoid generated by a set }\label{Ch2:freemonoid}

 \begin{itemize}[<+->]
\item `free' means: no more equalities than required by the laws
\item `generated by a set' means: no more elements in the monoid
 than in the set and required by the structure
\item Discussion: free and no generators, free and one generator, free and two generators, etc
\item A universal property: $[\_] : A \to [A]$ mapping 
$a\in A$ to the list $[a]$ of length 1 satisfies: for every monoid $(M,c,b)$ and $f: A\to M$
there is a unique monoid homomorphism $f^*: ([A],[],{\oplus}) \to (M,c,b)$ 
such that $f^*([a]) = f(a)$ % for all $a\in A$
\item Defining $f^*$ by list recursion: $f^*([]) = c$, 
$f^*([a]\oplus l) = b(f(a),f^*(l))$ for all $a\in A$ and $l\in[A]$
\item In Haskell: $f^*(l) = fold~b~c~(map~f~l)$, e.g. $fold\,{*}\,1\,[4,3] = 12$
\item Spelled out in script: $f^*$ monoid homomorphism and unique
 \end{itemize}

 }

\subsection{Functors}

\frame
  {   
    \frametitle{Functors}\label{Ch2:Functors}

 \begin{itemize}[<+->]
\item Functors are `category homomorphisms', preserving category structure,
i.e., graph homomorphisms that preserve the `extras'
\item A functor $F: \CC\to\DD$ is a graph homomorphism 
$F=(F_V,F_E): gr(\CC)\to gr(\DD)$ satisfying
   \begin{itemize}[<+->]
\item $F_E(f;^\CC g) = F_E(f);^\DD F_E(g)$ for all objects $A,B,C$ of $\CC$ 
and $f\in\CC(A,B)$, $g\in\CC(B,C)$
\item $F_E(id^\CC_A) = id^\DD_{F_V(A)}$ for all objects $A$ of $\CC$ 
   \end{itemize}
\item Examples: forgetful functors (boring) %, but instructive and sometimes useful)
   \begin{itemize}[<+->]
\item $F: \Mon \to \Set$ mapping $(M,c,b)$ to $M$ and a monoid homomorphism
$f: M\to N$ to $f$ as map of the carriers (what does this $F$ forget?)
\item  $G_V: \Gra \to \Set$ mapping a graph to its node set, and ...
\item  $G_E: \Gra \to \Set$ mapping a graph to its arrow set, and ...
   \end{itemize}
 \end{itemize}

 }

\frame
  {   
    \frametitle{More Functors}\label{Ch2:MoreFunctors}

 \begin{itemize}[<+->]
\item Example of a category: Haskell types and (terminating) functions
\item Example of a functor from this Haskell category to itself:
   \begin{itemize}[<+->]
\item For every Haskell type $T$ there is a type $[T]$ of lists over $T$
\item For every $f: T\to T'$ we have $map~f: [T] \to [T']$
   \end{itemize}
\item Recall that, e.g., $map~f~[a,b,c] = [f  a, f b, fc]$
\item The pair $(T\mapsto[T],\,map)$ preserves the structure of Haskell-as-a-category:
   \begin{itemize}[<+->]
\item $map~(f;g) = (map~f);(map~g)$
\item $map~id_T = id_{[T]}$
   \end{itemize}
\item Later: reversing lists, e.g., is a natural transformation, and can therefore be
programmed generically (`same code for all $[T]$')
 \end{itemize}

 }

\frame
  {   
    \frametitle{Product categories}\label{Ch2:ProdCats}

 \begin{itemize}[<+->]
\item The product category is based on the product of the underlying graphs
%$\CC = (\CC_V,\CC_E,sc^\CC, tg^\CC, id^\CC,(\_;^\CC\_))$
\item The product $G\times H$ of graphs $G = (G_V,G_E,sc^G, tg^G)$
and $H = (H_V,H_E,sc^H, tg^H)$ is the graph defined as follows:
   \begin{itemize}[<+->]
\item the collection of nodes is $G_V\times H_V$
\item the collection of arrows is $G_E\times H_E$
\item the source map is $sc^G\times sc^H : (G_E\times H_E)\to (G_V\times H_V)$
defined by $(sc^G\times sc^H)(f,g) = (sc^G(f), sc^H(h))$
\item the target map is defined analogously
   \end{itemize}
\item Example 2.6.6 in script
\item Definition 2.6.7 in script: the product category $\CC\times\DD$ 
has underlying graph $gr(\CC)\times gr(\DD)$ with composition $;^{\CC\times\DD}$
and $id^{\CC\times\DD}$ defined componentwise 
 \end{itemize}

 }

\frame
  {   
    \frametitle{More on Functors}\label{Ch2:MoreOnFunctors}

 \begin{itemize}[<+->]
\item Functors preserve iso's: if $F: \CC\to\DD$ is a functor and
$f:A\to B$ an iso, then $F(f): F(A)\to F(B)$ is also an iso
\item Proof: if $id^\CC_A = f;^\CC g$, then $id^\DD_{F(A)} = F(f) ;^\DD F(g)$ etc.
\item If $\CC$ is a subcategory of $\DD$, then we have a canonical 
\emph{inclusion functor} $in_{\CC,\DD}:\CC\hookrightarrow\DD$ (note the form of the arrow)
\item A functor $F: \CC\to\DD$ is an \emph{embedding} if both $F_V$ and $F_E$ are
injective
\item A functor $F: \CC\to\DD$ gives a map $F_{(A,B)}: \CC(A,B)\to\DD(F(A),F(B))$
and is called
   \begin{itemize}[<+->]
\item \emph{faithful} if  $F_{(A,B)}$ is injective for all objects $A,B$ of $\CC$
\item \emph{full} if  $F_{(A,B)}$ is surjective for all objects $A,B$ of $\CC$
   \end{itemize}
\item A subcategory $\CC$ of $\DD$ is \emph{full} 
if $in_{\CC,\DD}: \CC\hookrightarrow\DD$ is full, i.e., $\CC(A,B) = \DD(A,B)$ 
for all objects $A,B$ in $\CC$ (NB $\CC_ V \subseteq \DD_V$)
 \end{itemize}

 }

\frame
  {   
    \frametitle{Opposite category}\label{Ch2:OppCat}

 \begin{itemize}[<+->]
\item Given a category $\CC$, its opposite category $\CC^{op}$ has the same
objects, but all morphisms are reversed: $gr(\CC^{op}) = gr(\CC)^{op}$
\item This is simple, but can be confusing: $f: A\to B$ in $\CC$ is now a
morphism $B\to A$ in $\CC^{op}$ that we denote $f^{op}$. Now define:
   \begin{itemize}[<+->]
\item$g^{op};^{\CC^{op}} f^{op} = (f; g)^{op}$ if $g^{op}:C\to B$ and $f^{op}: B\to A$ in $\CC^{op}$
\item $id^{\CC^{op}}_A = (id^\CC_A)^{op} = id^\CC_A$ for all objects $A$,
so $id^{\CC^{op}} = id^\CC$
   \end{itemize}
\item We have $\CC^{op}(A,B)=\CC(B,A)$, $(\CC^{op})^{op}= \CC$ and $(f^{op})^{op}= f$
\item Functors $\CC\to\DD^{op}$ and $(\CC^{op})\to \DD$ are called
\emph{contravariant} functors from $\CC$ to $\DD$
\item Example: $\Rel^{op}$ has $\Rel^{op}(A,B)=\powset(B\times A)$
for sets $A,B$. Functor $conv: \Rel\to\Rel^{op}$ is the identity on objects 
and maps $R\in\powset(A\times B)$ to $R^c = \set{(b,a)\mid (a,b)\in R}$.
We also have $vnoc: \Rel^{op}\to\Rel$ mapping $S$ to $S^c$. NB The functors
$conv$ and $vnoc$ have different source and target.
 \end{itemize}

 }

\frame
  {   
    \frametitle{More Examples of Functors}\label{Ch2:MoreExaFunctors}

 \begin{itemize}[<+->]
\item Recall that for sets $A,B$ and $f: A\to B$ we have the defined
   \begin{itemize}[<+->]
\item the \emph{image} of  $X\subseteq A$ under $f$,
$f(X)=\set{f(x)\mid x\in X} \subseteq B$ 
\item the \emph{preimage} of  $Y{\subseteq} B$ under $f$,
$f^-(Y)=\set{a \mid f(a)\in Y} \subseteq A$ 
   \end{itemize}
\item These give two functors based on power sets
   \begin{itemize}[<+->]
\item $Pim:\Set\to\Set$ with $Pim(A) = \powset A$ and for all $f:A\to B$,
$Pim(f) : \powset A \to\powset B$ defined by $Pim(f)(X) = f(X)$
\item $Pom:\Set\to\Set^{op}$ with $Pom(A) = \powset A$ and %for all $f:A\to B$,
\begin{align*}
Pom(f)^{op} &\in \Set^{op}(Pom(A),Pom(B))\\ & =  \Set^{op}(\powset A,\powset B) \\&=
\Set(\powset B,\powset A), \text{~for all $f:A\to B$}
\end{align*} defined by 
$Pom(f)(Y)= f^-(Y)): \powset B \to\powset A$
\item Check (exercise): $Pim$ and $Pom$ are indeed functors %preserve category structure
   \end{itemize}
\item $Pom$ is a contravariant functor $\Set\to\Set$
 \end{itemize}

 }

\begin{frame}[fragile]
     
    \frametitle{Opposites}\label{Ch2:Opposites}

 \begin{itemize}[<+->]
\item $\Rel$ and $\Rel^{op}$ being isomorphic is a rare coincidence
\item The simplest category that is not isomorphic to its opposite is
\[
\begin{tikzcd}
1 & 2  \arrow[swap]{l}{a} \arrow[loop right]{l}{b} &\text{opposite:}~~
1 \arrow{r}{a} & 2   \arrow[loop right]{l}{b} 
\end{tikzcd}
\]
We put $b;b = id_2$ and (left) $b;a = a$ (NB $id_1,id_2$ omitted)
\item
Proof: any isomorphism would have to swap 1 and 2 because of $a$,
but this conflicts with $b: 2\to 2$ in both
\item Also: $\Set$ and $\Set^{op}$ are not isomorphic, by the following
   \begin{itemize}[<+->]
\item any iso preserves initial\footnote{%
object $i$ is initial in category $\CC$ if $\CC(i,x)$ a singleton for all objects $x$ of $\CC$} 
and final\footnote{%
object $f$ is final in category $\CC$ if $\CC(x,f)$ a singleton for all objects $x$ of $\CC$}
objects (why?)
\item  $\Set$ has one initial and many final objects (why?),  
$\Set^{op}$ the other way around (why?)
   \end{itemize}

 \end{itemize}
\end{frame}


\subsection{Category of categories}

\frame
  {   
    \frametitle{Category of categories}\label{Ch2:CatofCats}

 \begin{itemize}[<+->]
\item For any category $\CC$, we have an identity functor $id_\CC : \CC\to\CC$ 
which is a glorified identity graph homomorphism
\item For categories $\CC,\DD,\EE$, functors $F:\CC\to\DD$, $G:\DD\to\EE$,
we have $F;G$ as a composite of graph homomorphisms, and $F;G$ can easily
be seen to be a functor $\CC\to\EE$.
\item ID and ASS also hold for functors
\item The category $\CAT$ ($\Cat$) has as objects (small) categories
and functors as morphisms
\item Deep into CT size does matter, but here we don't bother too much 
\item An iso of categories is a functor $F: \CC\to\DD$ that has an 
inverse functor $G:\DD\to\CC$
\item Example of isos in $\CAT$: $conv$ and $vnoc$ on slide \ref{Ch2:OppCat} above
 \end{itemize}

 }


\subsection{Path Categories}

\frame
  {   
    \frametitle{Path Categories and Graphs}\label{Ch2:PathCatsGras}

 \begin{itemize}[<+->]
\item Given an ordinary graph with $E\subseteq V\times V$, the
reflexive transitive closure $E^*$ of $E$ is a preorder,
so we can consider the corresponding preorder category
\item This construction hides that there can be different paths
justifing $E^*(a,c)$, e.g., if $E(a,x), E(x,b), E(a,y), E(y,b)$
\item In a multigraph we can have multiple edges and we get
a more general construction: the path category of a multigraph
(in the above example we would get two morphisms (=paths) from $a$ to $c$)
\item One has to be careful in distinguishing the path from a node $n$ to itself
of length 0 (coming from the reflexive closure), and other such paths, 
e.g., using an existing arrow $f: n\to n$
\item Before defining the \emph{path category}, we define the
\emph{path graph} using lists, with paths of length 0 represented by empty lists
 \end{itemize}

 }

\frame
  {   
    \frametitle{Paths}\label{Ch2:Paths}

 \begin{itemize}[<+->]
\item Given a graph $G = (G_V,G_E,sc^G, tg^G)$, define:
   \begin{itemize}[<+->]
\item a pair $(f,g)$ of arrows is \emph{composable} if $tg^G(f) = sc^G(g)$
\item for every node $v\in G_V$ the \emph{empty path at} $v$ is an empty list
denoted $[]_v$, where $v$ is to remember source and target of this empty path
(the $[]_v$'s are a copies of the empty list, see below)
\item for every $n\geq 1$, any list $[f_1,\ldots,f_n]$ of arrows in $G_E$ such that each
pair of successive arrows is composable, is a path of length $n$ from
source $sc^G(f_1)$ to $tg^G(f_n)$
   \end{itemize}
\item A more explicit inductive definition of the above is:
 \begin{itemize}[<+->]
\item paths of length 0 in $G$ are triples $(v,[],v)$ for all $v\in G_V$
\item if $(v,[f_1,\ldots,f_n],u)$ is a path of length $n$ in $G$ and $f : w\to v$ in $G$,
then $(w,[f] \oplus [f_1,\ldots,f_n],u)$ is a path of length $n+1$ in $G$
   \end{itemize}
\item Also, we can concatenate \emph{composable} paths:
\[(w,p,v)\oplus(v,q,u) = (w,p\oplus q,u)\]
\item ID and ASS are satisfied
 \end{itemize}

 }

\frame
  {   
    \frametitle{Path Graphs}\label{Ch2:PathGras}

 \begin{itemize}[<+->]
\item Given a graph $G = (G_V,G_E,sc^G, tg^G)$, we define the \emph{path graph}
$P(G)$ as follows:
   \begin{itemize}[<+->]
\item the collection of nodes of $P(G)$ is $G_V$, the same as that of $G$
\item the collection of arrows of $P(G)$ is the collection of paths in $G$, of any length
\item the source function of $P(G)$ is defined by
$sc^{P(G)}([]_v) = v$ and $sc^{P(G)}([f_1,\ldots,f_n]) = sc^G(f_1)$
\item the target function of $P(G)$ is defined by
$tg^{P(G)}([]_v) = v$ and $tg^{P(G)}([f_1,\ldots,f_n]) = tg^G(f_n)$
\item With the inductive definition of $P(G)_E$ we get the source and target as
first and third projection, respectively
   \end{itemize}
\item For any category $\CC$, any graph homomorphism $\varphi: G\to gr(\CC)$
has a unique extension $\varphi^*: P(G)\to gr(\CC)$ defined by 
$\varphi^*_E([]_v) = id^\CC_{\varphi_V(v)}$,
$\varphi^*_E([f_1,\ldots,f_n]) = \varphi_E(f_1) ; \ldots  ;\varphi_E(f_n)$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Path Categories}\label{Ch2:PathCats}

 \begin{itemize}[<+->]
\item Path categories are also called \emph{free categories} generated by a graph:
\url{https://en.wikipedia.org/wiki/Free\_category}
\item Given a graph $G = (G_V,G_E,sc^G, tg^G)$, we define the \emph{path category}
$\PP(G)$ as follows:
   \begin{itemize}[<+->]
\item the underlying graph of $\PP(G)$ is the path graph of $G$
\item composition: list concatenation of composable paths 
\item identity morphisms: $id^{\PP(G)}_v = []_v$ for all $v\in\PP(G)_V = G_V$
\item ID and ASS hold as in the path graph (paths are lists)
   \end{itemize}
\item Again `free' means: no more equalities than required by the laws in vigor,
and `generated by a graph' means: no more elements than in the graph and
required by the structure (can be expressed by a universal property)
 \end{itemize}

 }

\frame
  {   
    \frametitle{Diagrams}\label{Ch2:Diagrams}

 \begin{itemize}[<+->]
\item Different diagrams can/not represent different things:
\[
\begin{tikzcd}[ampersand replacement=\&]
A\arrow[loop right]{l}{f} \& \&
A \arrow[yshift=1ex]{r}{f} \& A \arrow[yshift=-1ex]{l}{f}  \& \&
A \arrow{r}{f} \& B
\end{tikzcd}
\]
\item It is a priori unclear what a commutative diagram is
\item We make this precise by looking at the shape graph  of a
diagram and defining a graph homomorphism to the underlying graph the
a category in question
\item  Shapes: WYSIAllDistinct
\[
\begin{tikzcd}[ampersand replacement=\&]
1\arrow[loop right]{l}{x} \& \&
1 \arrow[yshift=1ex]{r}{y} \& 2 \arrow[yshift=-1ex]{l}{z}  \& \&
1 \arrow{r}{u} \& 2
\end{tikzcd}
\]
\item Easy graph homomorphisms in each of the examples above
 \end{itemize}

 }

\frame
  {   
    \frametitle{Commutative Diagrams}\label{Ch2:CommDiags}

 \begin{itemize}[<+->]
\item A \emph{diagram (in $H,\CC$) of shape} $J$ is a graph homomorphism
$\delta : J\to H$, if $H = gr(\CC)$ we simply write $\delta : J\to \CC$

\item A diagram $\delta : J\to \CC$ is \emph{commutative} if the
extension $\delta^* : P(J) \to gr(\CC)$ has the following property:
for any paths $p_1,p_2 : v\to u$ in $P(J)$, we have $\delta^*(p_1)=\delta^*(p_2)$
\item The latter condition is more tricky than it seems:
   \begin{enumerate}[<+->]
\item the equality $\delta^*(p_1)=\delta^*(p_2)$ is in $\CC(\delta(v),\delta(u))$
\item loops in $P(J)$ come from (a) empty paths, or (b) cycles in $J$
\item loops under (a) satisfy $\delta^*([]_v) = id^\CC_{\delta(v)}$ by definition;
loops $p: v\to v$ under (b) must thus also satisfy $\delta^*(p) = id^\CC_{\delta(v)}$
\item the commutativity of a finite diagram reduces \emph{always}
to finitely many cases (all non-cyclic paths)
\item empty paths are crucial in the case of cycles in the shape
   \end{enumerate}
\item Example, isomorphy:
\begin{tikzcd}[ampersand replacement=\&]
1 \arrow[yshift=0.5ex]{r}{y} \& 2, \arrow[yshift=-0.5ex]{l}{z}  \&
A \arrow[loop left]{}{id_A}\arrow[yshift=0.5ex]{r}{f} \& 
B \arrow[yshift=-0.5ex]{l}{g}\arrow[loop right]{}{id_B}
\end{tikzcd}

 \end{itemize}

}

\frame
  {   
    \frametitle{More on Diagrams}\label{Ch2:MoreOnDiags}

 \begin{itemize}[<+->]
\item Functors preserve diagrams: if $F:\CC\to\DD$ is a functor, $J$ a shape,
and $\delta : J\to \CC$ a diagram, then $\delta;F : J\to \DD$ is also a diagram
\item Evaluation of paths is functorial:
for any category $\CC$, any graph homomorphism $\varphi: G\to gr(\CC)$
we defined $\varphi^*: P(G)\to gr(\CC)$ and this can easily be seen
to be a functor $\varphi^*: \PP(G)\to \CC$
\item Practical:
   \begin{enumerate}[<+->]
\item We postpone 2.9 till after Easter
\item We summarize Chapter 2 on the next slide
\item Thereafter we continue with Chapter 3
   \end{enumerate}
 \end{itemize}

}

\frame
  {   
    \frametitle{Summary Chapter 2}\label{Ch2:Summary}

 \begin{enumerate}[<+->]
\item Directed multigraphs, graph iso/homomorphisms
\item Categories: graphs + composition + identities + ID + ASS
\item Sets and Relations, subcategories of $\Set$, $\Rel$, $\Mult$, preorder
and (partial) order category
\item Graphs: simple, ordinary; reflexive graphs, homomorphisms
\item Monoids: examples, $([A],\oplus,[])$, free monoid, homomorphisms
\item Functors; graph homomorphisms respecting ";" and $id$
\item Category of categories with functors as morphisms
\item Path categories = free categories generated by a graph, diagrams,
commutative diagrams
 \end{enumerate}


}

\frame
  {   
    \frametitle{Comments on script}\label{Ch2:comments}

 \begin{itemize}[<+->]
\item p. 19, Cor. 2.1.15: $in_V = in_{G_V,H_V}$, $in_E = in_{G_E,H_E}$
\item p. 29, Conv. 2.2.13: $C_V$ must be $C_E$ (twice)
\item p. 29, Rem. 2.2.15: in Haskell and type theory, composition would be
\emph{one} polymorphic function with type arguments $A,B,C$
\item Prop. 2.5.22 should read: (Universal property of the monoid of lists) 
 \end{itemize}

 }

\end{document}

\myurl{en.wikipedia.org/wiki/Ordered_pair}
 \begin{itemize}
    \item emulation halts because of the partiality of $\delta$;
    \item emulation halts because of "head left" with head at first cell;
    \item emulation halts because of reaching a halting state;
    \item the emulated TM goes on forever.
 \end{itemize}
