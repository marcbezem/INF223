\documentclass[handout]{beamer}
%\documentclass[slides]{beamer}
% Vary the color applet  (try out your own if you like)
%\colorlet{structure}{red!20!black}
%\beamertemplateshadingbackground{yellow!20}{white}
%\usepackage{beamerthemeshadow}
%\usepackage[utf8x]{inputenc} CONFLICT!
\usepackage{tikz}
%\usepackage[english,norsk,nynorsk]{babel}
\usepackage{tikz-cd}
\usetikzlibrary{trees}

\usepackage[all]{xy}
\usepackage{multicol}

%\setbeamertemplate{navigation symbols}{}++++++
%\setbeamertemplate{footline}[frame number]
\usetheme{Montpellier}


\input macros

\newcommand{\To}{\Rightarrow}
\newcommand{\Trt}{\stackrel{*}{\Rightarrow}}
\newcommand{\ToG}{\Rightarrow_G}
\newcommand{\redS}{{\color{red} S}}

\newcommand{\bfsf}[1]{{\boldsymbol{#1}}}
\newcommand{\Set}{\bfsf{Set}}
\newcommand{\Gra}{\bfsf{Graph}}
\newcommand{\CC}{\bfsf{C}}
\newcommand{\DD}{\bfsf{D}}
\newcommand{\EE}{\bfsf{E}}
\newcommand{\PP}{\bfsf{P}}
\newcommand{\HH}{\bfsf{H}}
\newcommand{\Nat}{\bfsf{Nat}}
\newcommand{\Incl}{\bfsf{Incl}}
\newcommand{\Rel}{\bfsf{Rel}}
\newcommand{\Mult}{\bfsf{Mult}}
\newcommand{\Mon}{\bfsf{Mon}}
\newcommand{\Cat}{\bfsf{Cat}}
\newcommand{\CAT}{\bfsf{CAT}}
\title[INF223 presentations]{}

\begin{document}

\section{Chapter 3}
\subsection{Natural transformations}
 
\frame
  {   
    \frametitle{Natural Transformations}\label{Ch3:NatTrans}

 \begin{itemize}[<+->]
\item Cold turkey: given functors $F,G: \CC\to\DD$, a \emph{natural transformation}
$\alpha: F\To G$ maps every object $A$ of $\CC$ to a morphism $\alpha_A : F(A)\to G(A)$
in $\DD$ such that, for every $f: A\to B$ in $\CC$ the following
\emph{naturality diagram} commutes:
\[
\begin{tikzcd}[ampersand replacement=\&]
A \arrow[swap]{d}{f} \& F(A)  \arrow[swap]{d}{F(f)}\arrow{r}{\alpha_A} \&\arrow{d}{G(f)} G(A)\\
B \& F(B)  \arrow{r}{\alpha_B} \& G(B)
\end{tikzcd}
\]
\item In $\HH$, Haskell-as-a-category, with types as objects and functions as morphisms:
   \begin{itemize}[<+->]
\item $[\_]_V$ maps any type $T$ to type $[T]$ of lists over $T$
\item $[\_]_E$ maps any $f: T\to T'$ to $map~f: [T] \to [T']$
\item $[\_]:\HH\to\HH$ is a functor, $reverse: [\_] \To [\_]$ is a natural transformation
   \end{itemize}
 \end{itemize}

 }

\frame
  {   
    \frametitle{What is natural about reversing lists?}\label{Ch3:reverse}

 \begin{itemize}[<+->]
\item Why is $reverse: [\_] \To [\_]$ a natural transformation?\\
Because this diagram commutes:
\[
\begin{tikzcd}[ampersand replacement=\&]
A \arrow[swap]{d}{f} \& {[A]}  \arrow[swap]{d}{map~f}\arrow{rr}{reverse_A} \&\& {[A]}\arrow{d}{map~f}\\
B \& {[B]}  \arrow{rr}{reverse_B}\& \& {[B]}
\end{tikzcd}
\]
\item What is natural about reversing lists?
That you can program this without knowing what the type of the elements is.
In other cultures, this is called \emph{generic programming},
or \emph{type polymorphism}
\item NB what naturality means depends on the categories $\CC,\DD$
 \end{itemize}

 }

\frame
  {   
    \frametitle{Yet another natural transformation}\label{Ch3:length}

 \begin{itemize}[<+->]
\item Functors can be constant
\item Example in $\HH$: the functor $C(\nat)$ 
   \begin{itemize}[<+->]
\item $C(\nat)_V$ maps any type $T$ to type $\nat$
\item $C(\nat)_E$ maps any $f: T\to T'$ to $id_\nat: C(\nat)(T) \to C(\nat)(T')$
   \end{itemize}
\item $[\_],C(\nat):\HH\to\HH$ are functors, $length: [\_] \To C(\nat)$ 
is a natural transformation. Why?
\item Because this diagram commutes:
\[
\begin{tikzcd}[ampersand replacement=\&]
A \arrow[swap]{d}{f} \& {[A]}  \arrow[swap]{d}{map~f}\arrow{rr}{length_A} \&\& \nat \arrow{d}{id_\nat}\\
B \& {[B]}  \arrow{rr}{length_B}\& \& \nat
\end{tikzcd}
\]
\item What is natural about computing the length of a list?\\
That you can program $length_A$ uniformly in $A$
 \end{itemize}

 }


\frame
  {   
    \frametitle{Universal Property of Cartesian Product}\label{Ch3:CartesianProductUP}

 \begin{itemize}[<+->]
\item Fact 1.1.1, picture and explanation on Whiteboard
\item Different implementation of $A\times B$ by $B\times A$ yields a bijection
$(A\times B) \to (B\times A)$, usually called $swap$
\item The universal property guarantees that \emph{any} implementation
of the cartesian product of sets yields such a bijection (`implementation independent')
\item This example shows the ingredients of a category (here $\Set$):
   \begin{itemize}[<+->]
\item Objects (here: sets)
\item Arrows (here: functions)
\item Composition of (certain) arrows, identity arrows
\item Properties: associativity and identity laws
   \end{itemize}
\item Also: we saw the first example of `diagram chasing'
 \end{itemize}

 }

\frame
  {   
    \frametitle{Dualization}\label{Ch3:sets}

 \begin{itemize}[<+->]
\item Dualization in CT means: reversing all arrows
\item Fact 1.1.2, picture and explanation on Whiteboard
\item Disjoint union: $A\uplus B := (A\times\set{1})\cup(A\times\set{2})$
\item Duals of projections are injections $A \to (A\uplus B)$, $B \to (A\uplus B)$
\item Dual of $\langle f,g\rangle : C \to (A\times B)$ is $[ f,g] : (A\uplus B) \to C$ ...
\item ... and this turns out to be case distinction!
 \end{itemize}

 }


\frame
  {   
     \frametitle{More basics}\label{Ch3:setbasics}

 \begin{itemize}[<+->]
\item Functions (or maps) $A\to B$ are total unless stated otherwise, 
$A$ is the domain (or source) $B$ is the codomain (or target)
\item We write $f: A\to B$ for $f\in (A\to B)$
\item Pairs can be generalized to $n$-tuples
\item $A^0 := \set{()}$, $A^{n+1}=A^n\times A$,
$A^* := List(A) := \cup_{n\in\nat} A^n$
\item $\powset_{fin}(A)$ is the set of finite subsets of $A$
\item Image and preimage of $f: A\to B$ for points and subsets 
\item Injective, surjective, bijective and idempotents maps
\item Inclusion map and epi-mono factorization: every map
is the (unique) composition of a surjection followed by an inclusion
 \end{itemize}

 }

\frame
  {   
    \frametitle{Some useful maps}\label{Ch3:usefulmaps}

 \begin{itemize}[<+->]
\item inclusion map $in_{A,B}$ for $A\subseteq B$, maps any $a\in A$ to $a\in B$
\item $del: A^* \to A^* $ removes subsequent duplicates (idempotent)
\item $sort: A^* \to A^* $, given an order on $A$, sorts (idempotent)
\item $len: A^* \to \nat $ gives the length of a list (surjective)
\item $forget: A^* \to \powset(A) $ gives the set of  elements of a list
\item $forget^e: A^* \to \powset_{fin}(A)$, image = codomain (surjective)
\item $forget$ is the composition of $forget^e$ and an inclusion
 \end{itemize}

 }

\frame
  {   
    \frametitle{Comments on script}\label{Ch3:comments}

 \begin{itemize}[<+->]
\item p. 6, last picture: $\pi'_1$ and  $\pi'_2$ interchanged
\item p. 7: notations $A.a$ and $a:A$ not good if $B=A$
 \end{itemize}

 }



\end{document}

\myurl{en.wikipedia.org/wiki/Ordered_pair}
 \begin{itemize}
    \item emulation halts because of the partiality of $\delta$;
    \item emulation halts because of "head left" with head at first cell;
    \item emulation halts because of reaching a halting state;
    \item the emulated TM goes on forever.
 \end{itemize}
